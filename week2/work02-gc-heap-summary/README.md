# 第2周作业


## 作业内容

1.写一段对于不同 GC和堆内存 的总结，提交到 Github。

2.写一段代码，使用 HttpClient 或 OkHttp 访问 http://localhost:8801 ，代码提交到 Github。


### GC
1.标记清除算法(Mark-Sweep)：
    分为两个阶段——标记阶段和清除阶段，首先标记出所以需要回收的对象，然后回收被标记的对象所占的空间
    缺点：容易产生垃圾碎片，碎片过多会导致后续程序为空间需求大的对象分配空间时，因为找不到足够的空间而提前触发新的一次GC操作

2.复制算法(Copying)
    思想是将内存按容量分为大小相等的A、B两块，每次只使用其中的一块内存；
    例如当A用完后，则将还存活的对象复制到B上，然后将这A的内存一次性清理掉，这样则不容易产生碎片。
    优点：高效、不易产生内存碎片
    缺点：内存空间代价高（缩减为一半）
    
    它开始的时候会把堆分为一个对象面和多个空闲面，程序会从对象面为对象分配空间，当对象满了，基于Copying算法的垃圾收集就从根集合（GC Roots）中扫描活动对象，并将每个活动对象复制到空闲面（使得活动对象所占的内存空间没有空闲洞），这样空闲面就变成了对象面，原来的对象面就变成了空闲面，程序会在新的对象面中分配内存

3.标记-整理算法（Mark-compact）
    标记之后，先不清理，先移动再清理回收对象
    为了解决Copying算法的缺陷，充分利用内存空间。

    内存标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。
    
    标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动。因此成本更高，但是解决了内存碎片的问题。

4.分代收集算法(Generatonal Collection)
    核心思想——根据对象存活的生命周期，将内存划分为若干个不同的区域；
    一般情况下分为老年代和新生代，在堆区之外还有一个代是永久代。

    老年代的特点：每次的垃圾回收时只有少量对象需要被回收
      
    新生代的特点：每次垃圾回收时都有大量的对象需要被回收
      
    那么就根据不同代的特点采取不同的收集算法——

      新生代采用的是复制（Copying）算法
          因为新生代每次垃圾回收都要回收大部分对象，也就是说复制的操作的次数较少。
          新生代的空间是分为三部分的一个较大的Eden区和两个较小的Survivor区。占比为8:1:1
      
          每次使用Eden区和Survivor区的From区的空间，当进行回收的时候，将Eden区和Survivor中还存活的对象复制到另一块Survivor中去，然后清理掉Eden区和刚才使用的Survivor区。
      
      由于老年代的特点是每次都回收少量的对象，一般使用的是标记整理算（Mark-Compact）法

          在新生代经过了n次的Gc后任然存活下来的对象（即超过指定的阀值的GC次数还存活的对象），就会被放在老年代中去，因此可以认为老年代中的对象都是存活的生命周期较长的对象
          内存也比新生代大很多（比例是1:2）
    
    当老年来内存满的时候触发Major Gc 即Full Gc，Full Gc发生的频率比较低
    当Eden区没有足够的空间的时候就会触发一次Minor Gc
    发生在新生代的GC叫做Minor GC,不一定等Eden区满了才触发的
    
    当To区空间不足以存放Eden区和Survivor区存活的对象的时候，就将存活的对象直接放到老年代中
    
    若是老年代也慢了就会触发一次Full GC（Major Gc）,也就是新生代和老年代都进行回收。


### 堆内存
  将堆内存与栈对比总结
1.应用程序所有的部分都使用堆内存，然后栈内存通过一个线程运行来使用；

2.不论对象什么时候创建，他都会存储在堆内存中，栈内存包含它的引用。栈内存只包含本地原始变量和堆中对象变量的引用；

3.存储在堆中的对象是全局可以被访问的，然而栈内存不能被其他线程所访问；

4.栈内存是生命周期很短的，然而堆内存的生命周期从程序的运行开始到运行结束；

5.我们可以使用-Xms和-Xmx JVM选项定义开始的大小和堆内存的最大值，我们可以使用-Xss定义栈的大小；

6.抛出的异常不同，当栈内存满的时候，Java抛出java.lang.StackOverFlowError异常而堆内存满的时候抛出java.lang.OutOfMemoryError: Java Heap Space错误；

7.和堆内存比，栈内存要小的多，因为明确使用了内存分配规则（LIFO），和堆内存相比栈内存非常快
